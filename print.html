<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Trophy case - Rust Fuzz Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guide on how to fuzz test software written in the Rust programming language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./introduction.html">Introduction</a></li><li><a href="./cargo-fuzz.html"><strong>1.</strong> Fuzzing with cargo-fuzz</a></li><li><ul class="section"><li><a href="./cargo-fuzz/setup.html"><strong>1.1.</strong> Setup</a></li><li><a href="./cargo-fuzz/tutorial.html"><strong>1.2.</strong> Tutorial</a></li><li><a href="./cargo-fuzz/targets.html"><strong>1.3.</strong> Targets</a></li></ul></li><li><a href="./afl.html"><strong>2.</strong> Fuzzing wth afl.rs</a></li><li><ul class="section"><li><a href="./afl/setup.html"><strong>2.1.</strong> Setup</a></li><li><a href="./afl/tutorial.html"><strong>2.2.</strong> Tutorial</a></li><li><a href="./afl/guide.html"><strong>2.3.</strong> Guide</a></li></ul></li><li><a href="./trophy-case.html"><strong>3.</strong> Trophy case</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust Fuzz Book</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p><a href="https://en.wikipedia.org/wiki/Fuzz_testing">Fuzz testing</a> is a software testing technique used to find security and stability issues by providing pseudo-random data as input to the software.</p>
<p><a href="https://www.rust-lang.org/">Rust</a> is a high performance, safe, general purpose programming language.</p>
<p>This book will demonstrate how to perform fuzz testing for software written in Rust. The two main sections cover two different approaches. The recommended approach is with <a href="cargo-fuzz.html">cargo-fuzz</a> as its setup and workflow are much easier than with <a href="afl.rs.html">afl.rs</a>.</p>
<a class="header" href="print.html#fuzzing-with-cargo-fuzz" id="fuzzing-with-cargo-fuzz"><h1>Fuzzing with cargo-fuzz</h1></a>
<p><a href="https://github.com/rust-fuzz/cargo-fuzz">cargo-fuzz</a> is the recommended tool for fuzz testing Rust code.</p>
<p>cargo-fuzz is itself not a fuzzer, but a tool to invoke a fuzzer. Currently, the only fuzzer it supports is <a href="http://llvm.org/docs/LibFuzzer.html">libFuzzer</a> (through the <a href="https://github.com/rust-fuzz/libfuzzer-sys">libfuzzer-sys</a> crate), but it could be extended to <a href="https://github.com/rust-fuzz/cargo-fuzz/issues/1">support other fuzzers in the future</a>.</p>
<a class="header" href="print.html#setup" id="setup"><h1>Setup</h1></a>
<a class="header" href="print.html#requirements" id="requirements"><h2>Requirements</h2></a>
<p>libFuzzer needs LLVM sanitizer support, so this is only works on x86-64 Linux and x86-64 macOS for now. This also needs a nightly compiler since it uses some unstable command-line flags You'll also need a C++ compiler with C++11 support.</p>
<a class="header" href="print.html#installing" id="installing"><h2>Installing</h2></a>
<pre><code class="language-sh">cargo install cargo-fuzz
</code></pre>
<a class="header" href="print.html#upgrading" id="upgrading"><h2>Upgrading</h2></a>
<pre><code class="language-sh">cargo install --force cargo-fuzz
</code></pre>
<a class="header" href="print.html#tutorial" id="tutorial"><h1>Tutorial</h1></a>
<p>For this tutorial, we're going to be fuzzing the URL parsing crate [rust-url][]. Our goal here is to find some input generated by the fuzzer such that, when passed to <code>Url::parse</code>, it causes some sort of panic or crash to happen.</p>
<p>To start, clone the rust-url repository and change directories into it:</p>
<pre><code class="language-sh">git clone https://github.com/servo/rust-url.git
cd rust-url
</code></pre>
<p>Although we could fuzz the latest commit on <code>master</code>, we're going to checkout a specific revision that is known to have a parsing bug:</p>
<pre><code class="language-sh">git checkout bfa167b4e0253642b6766a7aa74a99df60a94048
</code></pre>
<p>Initialize cargo-fuzz:</p>
<pre><code class="language-sh">cargo fuzz init
</code></pre>
<p>This will create a directory called <code>fuzz</code> which will contain a collection of <em>fuzzing targets</em>. Each fuzz target is a Rust program that is given random data and tests a crate (in this case, rust-url). <code>cargo fuzz init</code> automatically generates an initial fuzz target for us:</p>
<pre><code class="language-sh">cargo fuzz list
</code></pre>
<p>The source code for this fuzz target lives in <code>fuzz/fuzzers/&lt;fuzz target name&gt;.rs</code>. Open that file and edit it to look like this:</p>
<pre><code class="language-rust ignore">#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate url;

fuzz_target!(|data: &amp;[u8]| {
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = url::Url::parse(s);
    }
});
</code></pre>
<p>Random data is generated and passed as parameter <code>data</code> to the closure. The generated data is a bytes slice, so we'll need to convert it to a utf8 <code>&amp;str</code> since rust-url expect that when parsing.</p>
<p>To being fuzzing, run:</p>
<pre><code class="language-sh">cargo fuzz run &lt;fuzz target name&gt;
</code></pre>
<p>You're fuzzing!</p>
<p>rust-url: https://github.com/servo/rust-url</p>
<a class="header" href="print.html#targets" id="targets"><h1>Targets</h1></a>
<p>A collection of community maintained cargo-fuzz compatible fuzz targets can be found <a href="https://github.com/rust-fuzz/targets">here</a>.</p>
<a class="header" href="print.html#fuzzing-with-aflrs" id="fuzzing-with-aflrs"><h1>Fuzzing with afl.rs</h1></a>
<p><a href="http://lcamtuf.coredump.cx/afl/">American fuzzy lop</a> (AFL) is a popular, effective, and modern fuzz testing tool. <a href="https://github.com/rust-fuzz/afl.rs">afl.rs</a> allows one to run AFL on code written in <a href="https://www.rust-lang.org">the Rust programming language</a>.</p>
<a class="header" href="print.html#setup-1" id="setup-1"><h1>Setup</h1></a>
<p>At the time of writing, the recommended approach when using afl.rs is to use a prebuilt Docker image. For more information about why this necessary, read the section following this one.</p>
<p>To install Docker, see the instructions in the following link:</p>
<p><a href="https://docker.com/getdocker">docker.com/getdocker</a></p>
<p>Once you have installed Docker, retrieve the afl.rs image:</p>
<pre><code class="language-sh">docker pull corey/afl.rs
</code></pre>
<a class="header" href="print.html#why-is-docker-necessary" id="why-is-docker-necessary"><h2>Why is Docker necessary?</h2></a>
<p><em>Note: This is optional reading. Don't worry if you're confused by anything in this section.</em></p>
<p>AFL is a form of coverage-guided fuzzing (i.e. AFL requires insight into what code branches have been hit). In order to accomplish this, afl.rs includes a plugin for LLVM called an <em><a href="http://llvm.org/docs/WritingAnLLVMPass.html">LLVM pass</a></em>. This is accomplished via <a href="https://github.com/frewsxcv/afl.rs/blob/master/afl-plugin/afl-llvm-pass.so.cc">a C++ file</a> that afl.rs compiles and links against LLVM. Since Rust does <em>not</em> expose its LLVM internals, the user of afl.rs will have to either: compile the pass using tools that are ABI compatible with the Rust binary they're using or compile Rust from source. Neither of these options are trivial for the user. This guide used to recommend the former strategy, but <a href="https://github.com/frewsxcv/afl.rs/issues/57">this caused issues</a>. To get around this, this guide now recommends a Dockerfile which has rustc and afl.rs that are ABI-compatible.</p>
<a class="header" href="print.html#tutorial-1" id="tutorial-1"><h1>Tutorial</h1></a>
<p>For this tutorial, we are going to fuzz the URL parser <a href="https://github.com/servo/rust-url">rust-url</a>.</p>
<a class="header" href="print.html#clone" id="clone"><h2>Clone</h2></a>
<p>Clone the repository and navigate inside:</p>
<pre><code class="language-sh">git clone https://github.com/servo/rust-url
cd rust-url
</code></pre>
<a class="header" href="print.html#dependencies" id="dependencies"><h2>Dependencies</h2></a>
<p>Modify <code>Cargo.toml</code> and add the following lines to the <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">afl = &quot;0.1&quot;
afl-plugin = &quot;0.1&quot;
</code></pre>
<p>The <code>afl-plugin</code> crate includes a compiler plugin that will be used to instrument the rust-url crate. The <code>afl</code> crate will be used to setup the necessary runtime afl expects during afl-fuzz. Also, it has a few other utilities.</p>
<a class="header" href="print.html#instrumentation" id="instrumentation"><h2>Instrumentation</h2></a>
<p>Open up <code>src/lib.rs</code> and add these two lines before all other non-documentation/non-comment lines:</p>
<pre><code class="language-rust ignore">#![feature(plugin)]
#![plugin(afl_plugin)]
</code></pre>
<p>The first line indicates to the compiler that we are opting-in to an unstable Rust feature: <a href="https://doc.rust-lang.org/book/compiler-plugins.html">compiler plugins</a>. The second line specifies which compiler plugin we want to use. This particular compiler plugin will add the AFL instrumentation to the rust-url crate.</p>
<a class="header" href="print.html#driver" id="driver"><h2>Driver</h2></a>
<p>AFL requires an executable that will read from stdin. Create a new file <code>src/main.rs</code> and add the following contents:</p>
<pre><code class="language-rust ignore">#![feature(plugin)]
#![plugin(afl_plugin)]

extern crate afl;
extern crate url;

fn main() {
    afl::handle_string(|s| {
        let _ = url::Url::parse(&amp;s);
    })
}
</code></pre>
<a class="header" href="print.html#input" id="input"><h2>Input</h2></a>
<p>AFL needs an input directory with test cases.</p>
<p>Make a new directory <code>in</code> and add a test:</p>
<pre><code class="language-sh">mkdir in
echo &quot;https://rust-lang.org&quot; &gt; in/basic
</code></pre>
<a class="header" href="print.html#build" id="build"><h2>Build</h2></a>
<p>You'll need to enter the Docker environment to get the binary to compile correctly:</p>
<pre><code class="language-sh">docker run -v $(pwd):/source -it corey/afl.rs sh
</code></pre>
<p>Run <code>cargo build</code> to compile it. It will create an executable at <code>target/debug/url</code>.</p>
<a class="header" href="print.html#fuzz" id="fuzz"><h2>Fuzz</h2></a>
<pre><code class="language-sh">afl-fuzz -i in -o out target/debug/url
</code></pre>
<a class="header" href="print.html#exiting" id="exiting"><h2>Exiting</h2></a>
<p>You can exit <code>afl-fuzz</code> by pressing <code>ctrl-c</code> and you can exit the Docker environment by running the <code>exit</code> command.</p>
<a class="header" href="print.html#guide" id="guide"><h1>Guide</h1></a>
<a class="header" href="print.html#deferred-init" id="deferred-init"><h2>Deferred init</h2></a>
<p>If your program has a slow set-up phase that does not depend on the input data,
you can set <code>AFL_DEFER_FORKSRV=1</code> for a substantial speed-up, provided that you
insert a call to <code>afl::init()</code> after the set-up and before any
dependence on input. There are various other caveats, described in the section
&quot;Bonus feature: deferred instrumentation&quot; in <code>llvm_mode/README.llvm</code>
distributed with afl. See also <a href="https://github.com/frewsxcv/afl.rs/blob/master/examples/deferred-init.rs"><code>examples/deferred-init.rs</code> in the afl.rs repository</a>.</p>
<a class="header" href="print.html#conditional-compilation" id="conditional-compilation"><h2>Conditional compilation</h2></a>
<p>afl instrumentation adds some run-time overhead, so it's a good candidate for
<a href="https://doc.rust-lang.org/reference.html#conditional-compilation">conditional compilation</a>, perhaps through a <a href="http://doc.crates.io/manifest.html#the-%5Bfeatures%5D-section">Cargo feature</a>:</p>
<pre><code class="language-toml"># You may need to add `optional = true` to the above dependencies.
[features]
afl = [&quot;afl-plugin&quot;, &quot;afl&quot;]
</code></pre>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Active only with `cargo [...] --feature afl`
#![cfg_attr(feature = &quot;afl&quot;, feature(plugin))]
#![cfg_attr(feature = &quot;afl&quot;, plugin(afl_plugin))]

#}</code></pre></pre>
<a class="header" href="print.html#afl-configuration" id="afl-configuration"><h2>AFL configuration</h2></a>
<p>See the afl documentation for other configuration variables. Some of these are
set at compile time in <code>config.h</code>. For the most part they only affect
<code>afl-fuzz</code> itself, and will work fine with this library. However, if you change
<code>SHM_ENV_VAR</code>, <code>MAP_SIZE</code>, or <code>FORKSRV_FD</code>, you should update this library's
<code>src/config.h</code> to match.</p>
<a class="header" href="print.html#trophy-case" id="trophy-case"><h1>Trophy Case</h1></a>
<p>A collection of bugs found in Rust code through fuzz testing can be found in <a href="https://github.com/rust-fuzz/trophy-case">the trophy-case repository</a>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
